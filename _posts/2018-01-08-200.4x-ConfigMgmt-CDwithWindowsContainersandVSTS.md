---
layout: page
title:  Continuous Delivery with Windows Containers and Azure Devops
category: ConfigMgmt
order: 4
---


In this lab we will create a new Azure DevOps project and configure it to allow us build and deploy our container image. We will also deploy an Azue virtual machine to use as our Azure DevOps build agent. We will then create build and release pipelines and deploy our application to a test environment, performing a smoke test om the container.



<h3><span style="color: #0000CD;">DevOps MPP Course Source </span></h3>

- This lab is used in course <a href="https://www.edx.org/course/configuration-management-containerized-microsoft-devops200-4x-0" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Configuration Management for Containerized Delivery</span></a> - Module 1.


<h3><span style="color: #0000CD;"> Pre-requisites:</span></h3>

- Completion of the earlier container lab <a href="http://microsoft.github.io/PartsUnlimited/configmgmt/200.4x-ConfigMgmt-WorkingwithContainers.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Working with Containers </span></a>. An **Azure Container Registry** is required in this lab and it re-uses the one created in that earlier lab.
- An <a href="https://docs.microsoft.com/en-us/vsts/accounts/create-account-msa-or-work-student" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Azure DevOps account </span></a>
- Visual Studio 2017 (we will add Docker support to the PartsUnlimited application using Visual Studio 2017. If you do not have Visual Studio 2017, VS2017 commuity edition is available from [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/))
- You require a Build agent; there are several options in VSTS. However, in this exercise we will deploy a container to the build agent and view the output so we require containers to be available on the virtual machine and thus nested virtualization capability. For this exercise you have two options, the steps in the lab will be based on the Azure virtual machine scenario, but you can choose either one.
  - An Azure Virtual machine
    - This will require an Azure Subscription; you can view the Azure setup section, at the start of this document, for details on how to set up a free Azure subscription.
    - We would recommend you use the image Windows Server 2016 Datacenter â€“ with Containers
    - You will also need to follow the steps below to install and configure the build agent.
  - A local Windows 10 environment
    - The steps for installing and configuring the build agent can be performed on the Windows 10 client as well as the Azure virtual machine.
- An Azure Container Registry
  - You will need to Azure Container registry that you set up earlier in Exercise 4 earlier in this document.
  - This requires an Azure subscription. It can be set up using the free Azure subscription being used for the Azure virtual machine above.
- You will need the Dockerfile and Index.html that you created in the earlier lab <a href="http://microsoft.github.io/PartsUnlimited/configmgmt/200.4x-ConfigMgmt-WorkingwithContainers.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Working with Containers </span></a>
- You will also need the IIS image < iiscntr1 > that you created in the earlier lab <a href="http://microsoft.github.io/PartsUnlimited/configmgmt/200.4x-ConfigMgmt-WorkingwithContainers.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Working with Containers </span></a>


<h3><span style="color: #0000CD;"> Lab Tasks:</span></h3>

- Task 1. Create a new Azure DevOps Project
- Task 2. Create Git repo and Import PartsUnlimited git repo
- Task 3. Create a Personal Access Token (PAT)
- Task 4. Create a Service Connection in Azure DevOps
- Task 5. Add Docker support to the application using Visual Studio 2017
- Task 6. Crate Azure Container Registry
- Task 7 : Deploy a virtual machine to Azure to use as an Azure DevOps build agent
- Task 8:  Install and configure the build agent
- Task 9: Create a Build Pipeline
- Task 10: Create a Release Pipeline
- Task 11: Run the full Continuous Integration and Continuous Deployment pipeline
- Task 12: Optional additional configuration on release pipeline



<h3><span style="color: #0000CD;">Estimated Lab Time:</span></h3>

- approx. 90 minutes  



### Task 1: Continuous Delivery with Windows Containers and VSTS

In this exercise you will create a build and deployment pipeline to run your custom created docker image on a build machine for validation


The complete video of this exercise can be found in the course.

Lab files required for the lab taks are available at <a href="https://github.com/Microsoft/PartsUnlimited/tree/master/Labfiles/Devops200.4x-ConfigMgmtForContainerizedDelivery/M01/Demos/Demo1.6.4-M01-L07-Create_CD_PIpeline_using_containers_and_VSTS" target="_blank"><span style="color: #0066cc;" color="#0066cc"> https://github.com/Microsoft/PartsUnlimited/tree/master/Labfiles/Devops200.4x-ConfigMgmtForContainerizedDelivery/M01/Labs/ </span></a>


### Task 1: Create a new Azure DevOps Project

1. If you need, in Azure DevOps create a new project and name it **Cntr1Proj** or something like that, accepting the default values for Version control and Work item process.


	![](../assets\cdwithcontainersandazdevops-jan2018/createproject1.png)
	![](../assets\cdwithcontainersandazdevops-jan2018/crateprpoject2.png)


### Task 2: Create Git repo and Import PartsUnlimited git repo
1. In your new project clock on **Repos** > **Files** Click on **Import** and then import the PartsUnlimted git repo

 	![](../assets\cdwithcontainersandazdevops-jan2018/createrepo1.png)
	![](../assets\cdwithcontainersandazdevops-jan2018/createrepo2.png)
	![](../assets\cdwithcontainersandazdevops-jan2018/createrepo3.png)

2. In your project **Repo** > **Files** Note the URL of your repo by clicking on **Clone** and then copying the URL value. It will be required later.
 
    ![](../assets\cdwithcontainersandazdevops-jan2018/createrepo3.png)


### Task 3 : Create a Personal Access Token (PAT)

1. In your Azure DevOps project click on your profile icon in the top right hand corner and select **Security**

    ![](../assets\cdwithcontainersandazdevops-jan2018/securityicon.png) 

2. Under **Personal Access Tokens**, click **+ New Token**

    ![](../assets\cdwithcontainersandazdevops-jan2018/pat1.png) 
 
3. In the Create a new personal access token pane, enter the values required and click **Create**.

    - **Name** = enter a name 
    - **Organization** = accept the defaults, should be your organization
    - **Expiration** = accept the defaults
    - **Scopes** = Full access

    ![](../assets\cdwithcontainersandazdevops-jan2018/pat2.png) 

4. In the **Success!** pane copy the token value and take a note of it. Paste it into notepad on your local C: drive, so you have it easily, as it will be required later in the lab. We will configure an rdp connection later to share the local C drive and allow us copy and paste this value into a build agent VM. You will not be able to access the token value again. If you do not have the token when needed you will need to create a new one. We will configure our connectin later to share the local C drive
    
    ![](../assets\cdwithcontainersandazdevops-jan2018/pat3.png) 


### Task 4. Create a Service Connection in Azure DevOps

You will also require a **service connection** in your Azure DevOps project to allow you connect to Azure when running your build and release pipelines. 

If you do not have a service connection configured in your Azure Devops project you can follow the steps in **Task 3: Setting up Service Connection in VSTS** in the lab  <a href="https://microsoft.github.io/PartsUnlimited/pandp/200.1x-PandP-CICDQuickstartwithVSTS.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> CI and CD with Azure DevOps - Quickstart  </span></a> to create one.


### Task 5. Add Docker support to the application using Visual Studio 2017

**Note**: It is not essential to use Visual Studio to add docker support to your application, you can manually create the Docker files that you require and include them with your application. They are also made available in the labfiles in our PartsUnlimited application repo. However we will use Visual Studio in this instance to demonstrate the capability in Visual Studio.

1. On your local machine install [Visual Studio 2017](http://www.visualstudio.com). If you do not have Visual Studio 2017 installed you can use the Community edition, available on [http://www.visualstudio.com](http://www.visualstudio.com)

2. On your local machine create a local folder to place your Azure DevOps repo files i.e. **C:\Repos\PUCntr1proj**


3. On your local machine, open **Visual Studio 2017** and go to **Team Explorer** then click on **Manage connections** icon and under local it repositories select **Clone** and enter the URL of your Azure DevOps repo, which you noted earlier, and enter the path to the local folder you created earlier, then click **Clone**
 

 	![](../assets\cdwithcontainersandazdevops-jan2018/createlocalrepo1.png)

4. Open the PartsUnlimited solution in Visual studio, you can do so, by opening **Solution Explorer** and double clicking on **PartsUnlimited.sln**.It may take a few minutes as dependencies will be installed, indicated by an yellow warning sign over some folder i.e. under the **PartsUnlimitedWebsite folder\Dependancies**, wait until that has finished, i.e. when the yellow warning sign is no longer present.

    **Note**: You do **not** need to a manual build of the application prior to adding Docker support. If you do build the application you may encounter some errors. You can see details about addressing potential errors and getting the application to successfully build in Visual Studio in the lab <a href="https://microsoft.github.io/PartsUnlimited/pandp/200.1x-PandP-PUsetupwithVS2017.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> PartsUnlimited Setup with Visual Studio</span></a>Details 



    ![](../assets\cdwithcontainersandazdevops-jan2018/vs1.png)
    ![](../assets\cdwithcontainersandazdevops-jan2018/vs2.png)

5. Open a command prompt at your repo location and go to the folder src\partsUnlimtedWebsite and run the command. This is just to reduce the risk of receiving errors if you build the PartsUnlimited application.

    ```
    npm rebuild node-sass
    ```

    ![](../assets\cdwithcontainersandazdevops-jan2018/npmrebuildnodesass.png)


6. In **Solution Explorer** right click **PartsUnlimitedWebsite** and select **Add** > **Docker Support**, and then chose **Windows** as the **Target OS** in the Docker Support Options prompt. This creates several docker container files and kicks off a build using those container files.

    ![](../assets\cdwithcontainersandazdevops-jan2018/vs3.png)
    ![](../assets\cdwithcontainersandazdevops-jan2018/vs4.png)
    ![](../assets\cdwithcontainersandazdevops-jan2018/vs5.png)


7. Several files are created in your solution, listed below. Open and browse through them to try understand what they are doing. These are the files we will use in our build and release pipeline.

    - `docker-compose`
        - `dockerignore`
        - `docker-compose.yml`
        - `docker-compose.override.yml`
    - `PartsUnlimitedWebsite`
        - `Dockerfile`
    
    ![](../assets\cdwithcontainersandazdevops-jan2018/vs6.png)

8. Open the file **PartsUnlimitedWebsite\Dockerfile** and make the following changes. 
    
    modify **line 5** to read as below. This is because we will build our application within the container and we require a non nano-server container image to successfully build our application.

  
    ```
    FROM microsoft/aspnetcore-build:2.0 AS build
    ```
    Add the following command at **line 11**. This is to overcome a dependency issue in our application and ensure a successful build.

    ```
    RUN npm rebuild node-sass
    ```
    
    After you make the changes the Dockerfile should look as below
    ![](../assets\cdwithcontainersandazdevops-jan2018/vs7.png)


9. Push the changes to your Azure devops repo by clicking the **Manage Connections** icon and clicking **Sync**. Then clicking **commit** for your listed changes to commit them changes you made to the Dockerfile to your local repo. Then click **push** to push the changes to you Azure DevOps project repo.

    **Note**: You could also use git from the command line if you have it installed.


    ![](../assets\cdwithcontainersandazdevops-jan2018/azdev1.png)

    You now have the files you need in your Azure DevOps repo to create a build pipeline for PartsUnlimited to be built into a container which we can then deploy.


### Task 6. Crate Azure Container Registry

This lab requires an Azure Container Registry. if you do not have one set up see the lab <a href="http://microsoft.github.io/PartsUnlimited/configmgmt/200.4x-ConfigMgmt-WorkingwithContainers.html" target="_blank"><span style="color: #0066cc;" color="#0066cc"> Working with Containers </span></a> to create one.




### Task 7 : Deploy a virtual machine to Azure to use as an Azure DevOps build agent

It is possible, and sometimes preferable and easier to use the VS2017 agent available in Azure DevOps, however we will be deploying a container to the build agent and as such, we will configure a dedicated machine. We will use an Azure virtual machine. However, it is possible to also use your local environment, if you have a Windows 10 machine, and the steps below are equally applicable to that.

In general, building on a local machine and verifying your work when checking in files before, committing to a master branch can be very useful and efficient.

Also, when building containers another factor to take into account is when a container pipeline is run if a new hosted build agent is used the container images need to be downloaded each time onto that build agent, and that will increase your build time. Using a local build agent or a virtual machine in Azure, would mean if the images are already present on the build agent, they would not need to be downloaded again, thus reducing the build time.

The next few steps will be carried out on an azure virtual machine

1. To deploy a virtual machine to Azure to use as our Azure Devops build agent click on the **Deploy to Azure** button below


	<a href="

https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fraw.githubusercontent.com%2FMicrosoft%2FPartsUnlimited%2Fmaster%2FLabfiles%2FDevops200.4x-ConfigMgmtForContainerizedDelivery%2FM01%2FLabs%2FBuildAgent%2Fbuidlagentdeploy.json" target="_blank">
		<img src="http://azuredeploy.net/deploybutton.png"/>
	</a>
	<a href="http://armviz.io/#/?load=https%3A%2F%2Fraw.githubusercontent.com%2FMicrosoft%2FPartsUnlimited%2Fmaster%2FLabfiles%2FDevops200.4x-ConfigMgmtForContainerizedDelivery%2FM01%2FLabs%2FBuildAgent%2Fdeploybuildagent.json" target="_blank">
		<img src="http://armviz.io/visualizebutton.png"/>
	</a>

2. Fille in the details as required and outlined below and deploy the virtual machine by clicking **Purchase**. It will take approximately 10 mins to deploy.

    - **Resource Group** = specify a new resource group name
    - **Location**  = choose an Azure datacenter location near you
    - **Admin Username**  = use the default value of **azureuser**
    - **Admin Password**  = enter a password value
    - **Dns Label Prefix** = enter some unique dns name for the build agent VM i.e. azdevgentek01
    - - **Windows OS version**  = leave the default value **2016-Datacenter-with-containers**
    - **Location**  = leave the default value **[resourceGroup().location]** which ensure all resources are placed in the same new resource group you specified earlier

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagent1.png)


2. When the deployment is complete, go to the newly created resource group, and then the virtual machine and obtain the dns name of the virtual machine.

    ![](../assets\cdwithcontainersandazdevops-jan2018/vmdnslabel.png)

3. On your local machine open **Remote Desktop Connection** and paste in the dns label of the virtual machine into the Computer box and click connect, 

    ![](../assets\cdwithcontainersandazdevops-jan2018/vmconnect.png)


4. Enable sharing of a local drive in rdp session to allow you copy and paste any details you need during the configuration of the agent by clicking **show options** in the **remote desktop connection** dialogue, then going to the **Local Resources** tab and clicking on **More...**

    ![](../assets\cdwithcontainersandazdevops-jan2018/rdp2.png)

5. Under **Local devices and resources** select your local C drive.

    ![](../assets\cdwithcontainersandazdevops-jan2018/rdp3.png) 

4. In the **Windows Security - Enter your credentials** dialogue click **More Choices** and select **Use a different account** then enter the username and password you used earlier when deploying the build agent virtual machine and click **OK** i.e.

    - User Name = azureuser
    - Password = < password value you specified earlier > 

    ![](../assets\cdwithcontainersandazdevops-jan2018/vmconnect2.png)

5. Accept the certificate prompt by clicking **Yes**

    ![](../assets\cdwithcontainersandazdevops-jan2018/vmconnect3.png)


6. Once logged into the virtual machine, allow it to start and then open a command prompt as administrator, and run the below docker command just to verify docker is installed and available

    ```
    docker
    ```

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentruncmd.png)





### Task 8:  Install and configure the build agent

We now need to download and configure the agent on the build agent. The following steps can be carried out on your build agent.

We deployed a Server image with a GUI and container support as our virtual machine to use a build agent for demonstration purposes. As a result, we need to perform some additional steps to allow us configure our virtual machine as a build agent, but they would not be recommended in production environments.

1. Signed into your build agent, if you are using the azure virtual machine deployed earlier, open **Server Manager**, select **Local server** and then under **IE Enhanced Security Configuration.** click **On**

    ![](../assets\cdwithcontainersandazdevops-jan2018/servermanagerIE1.png)

2. In the **Internet Explorer Enhanced Security Configuration** dialogue choose Off for both Administrators and users and click **OK**

    ![](../assets\cdwithcontainersandazdevops-jan2018/servermanagerIE2.png)

3. Access your Azure DevOps account from within the build agent, i.e. the azure virtual machine. You can do this in **Internet Explorer**, which is available on the server. This just makes it easier to install and configure the build agent on the build agent directly.

    Note: You may get prompted to add **visualstudio.com** and some other sites  to trusted sites in the virtual machine, you can add these as you sign in, to prevent them appearing if you log in again later if you wish.

4. In your Azure DevOps project, go to **project settings** and then **Pipelines** choose **Agent pools** and then select **Download agent**


    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm2.png)


5. In the **Get agent** pane, click **Download** and save the agent to the default location. Leave the Get agent dialogue open, as you will copy the commands you need to run from here.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm3.png)

6. Open PowerShell as an administrator and go to the root of the drive using the below command.

```
cd\
```
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm4.png)
\
7. Return to the **Get agent** window, copy the **first** line in the commands listed, as below, paste it into PowerShell and run it i.e. 

    ```powershell
    Mkdir agent ; cd agent
    ```
    This just creates a folder C:\agent and enters that folder

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm5.png)


8. Return to the **Get agent** window, copy the **first** line in the commands listed, as below, paste it into PowerShell and run it. It should look something like the below,

    ```powershell
    Add-Type -AssemblyName System.IO.Compression.FileSystem ; [System.IO.Compression.ZipFile]::ExtractToDirectory("$HOME\Downloads\vsts-agent-win-x86-2.141.1.zip", "$PWD")
    ```

    Note: Ensure you copy the command from the window and not this document, as the file version will change over time and the get agent dialogue command will have the latest version.`

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm6.png)


9. Open a command prompt window as administrator, go to the folder **C:\Agent** and run the command

    ```powershell
    .\config.cmd
    ```
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm7.png)

10. Enter the below values when prompted
    
    **Note**: You will be prompted to enter the PAT that you created earlier, if you saved the PAT value in a txt file to your local C: drive, and you modified your rdp file to share the local drive, the values in that txt file should be available to copy and paste into the virtual machine now. The C drive will be present in **File Explorer** under **This PC**. If you have not and the drive is not available, you could disconnect your rdp session, re-configure the rdp session to share a local drive and place the data you need into a text file so it is available to copy into the command prompt when you need below. See steps earlier when connecting vis rdp for details on how to do this. You can also place other details required below into this file for use if needed.
    
    - Connect:
        - **Enter server URL**: https://< yourAzureDevOpsaccountname >.visualstudio.com
        - **Enter authentication type (press enter for PAT)**: < press Enter >
        - **Enter personal access token**: < Paste the value you obtained in the Create a Personal Access token section earlier i.e. it should look something like 4avrb33twjq3f5wlqbkx7jzimmzt6h7ktyybbdojtu32x7yd3t2q >

    - Register Agent:
        - **Enter agent pool (press enter for default)**: < Accept default by pressing Enter >
        - **Enter agent name (press enter for <your machine name>)**: < Accept default by pressing Enter >
        - **Enter work folder (press enter for _work)** >< Accept default by pressing Enter >
        - **Enter run agent as service? (Y/N) (press enter for N)** > < enter Y >
        - **Enter User account to use for the service (press enter for NT AUTHORITY\NETWORK SERVICE)**: < Enter the value NT Authority\SYSTEM >

        **Note:** If you use the default account, i.e. the NT **Authority\Network Service** account, it will **not** have sufficient Log on as Service permissions to successfully complete the Azure DevOps build tasks and you will receive an error when you go to build. You could also modify the service account settings for VSTS Agent <accountname>.<machinename> in the Services.msc, and modifying the Log on as a Service setting there.

        - You should receive several successful messages as it installs and configures the agent settings.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm8.png)

11. In Azure DevOps project, go to **Project settings** > **Pipelines** > **Agent pools** again and then under **All agent pools** select the **Default** and verify your machine is listed and has a State of Online.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm9.png)


12. Open a Powershell console as administrator and run the below command to install chocolatey. This is a package manager and will allow us to easily install some additional software.

    ```powershell
    Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
    ```
 
 
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm10.png)

13. In the powershell console run the below command to install docker for windows and, docker-compose which is needed for our build. Press **Y** to confirm when prompted to run the script.
 
    ```powershell
    choco install docker-for-windows -y
    ```

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm11.png)

    **Note**: Ensure that docker is set for Windows containers. If it is set for Llinux containers you may receive errors. You can check by clicking the docker icon in the system tray and choosing **Switch to Windows Containers...** if it is set for Linux. If the docker icon context menu says **Switch to Linux Containers...**, that means it is set on Windows containers and is fine.


14. Close the powershell console and open a command prompt window as administrator, then run the below command to install visual studio 2017 community edition, which is needed for our build. Press **Y** to confirm when prompted to run the script.

    Note:  This is a free edition of visual studio and while this is not strictly required to be the build agent, there are components within it that are required for our build, and it may assist with troubleshooting, as such we will install it now.
 
    ```powershell
    choco install visualstudio2017community -y
    ```

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildagentvm12.png)

15. In the command prompt window running as administrator run the below commands one after the other

    ```
    choco install visualstudio2017-workload-azure -y
    ```
    
    then
    
    ```
    choco install visualstudio2017-workload-netweb -y
    ```
    
16. When complete, restart your virtual machine and log in.  Your build agent is now ready and available. 

    **Note**: Its a good idea to run some docker commands such as **docker**, **docker ps** and **docker-compose**, and make sure they perform as expected. If they do not, you will need to get them working by stepping back through the details in the earlier steps, otherwise you may receive build errors when you go to build your application.



### Task 9: Create a Build Pipeline
Note: As releases and updates occur frequently in zure DevOps, there may be some differences in the steps below and what appears in the zure Devops environment. Where discrepancies occur you should try to adhere to the main configuration points below and accept the default values where possible. 

You do not need to perform these steps in the azure virtual machine build agent, they can be performed on your local machine if you wish.

1. In your Azure Devops project go to **Pipelines** > **Builds** and then select **New Pipeline**.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline1.png)

2. Under **Select a source** accept the defaults and click **Continue**
 
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline2.png)

3. Under **Select a template** scroll down until and select **ASP.NET with containers**. This will just pre-populate the build pipeline with a series of tasks which we cna then edit.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline3.png)

4. Under **Tasks** > **Pipeline**, In the Default agent queue drop down choose Default
    
    - **Name**: change the build pipeline name to something like PUcntrs1 
    - **Agent Pool**: Default (This will lead us to use the build agent virtual machine we deployed to Azure earlier. We could use the **Hosted Windows Containers** option, and it can be a quick an easy option to use if you need, but we wish to do additional configuration in on the build agent and using our own customised agent will give us some permanence and allow us to do this. You can see a list of the configurations on the page [https://www.visualstudio.com/en-us/docs/build/concepts/agents/hosted](https://www.visualstudio.com/en-us/docs/build/concepts/agents/hosted) 
    - **Solution**: PartsUnlimited.sln < Use the ellipsis button beside the box to point to the PartsUnlimited.sln file at the root of our repo.>
    - **Docker Compose File**: docker-compose.yml < Use the ellipsis button beside the box to point to the docker-compose.yml file at the root of our repo. >
    - **Azure Subscription**: < The Azure **service connection** you created earlier, it should be available in the drop down box. If not you will need to create a service connection as per earlier steps. >
    - **Azure Container Registry**: < The azure container registry you created you created earlier. Again if none is listed ensure you're service connection and azure container registry are created and available as in the steps earlier in the lab. >

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline4.png)

5. Under **Tasks** > **Get Sources** accept the default values.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline5.png)

6. Accept the default values for **Agent job 1** and also for the tasks **Use NuGet 4.4.1** and **NuGet restore**

7. Right click on the task **Build solution PartsUnlimited.sln** and from the context menu choose **X Remove selected tasks(s)**. We will build the app inside a container which is being called within the dockerfile, so we do not need to build the app on the agent itself.
 
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline6.png)


8. Configure the **Build services** task using the below settings. If a setting is not mentioned below leave the default settings.
    
    - **Display name**: Build an image
    - **Container Registry Type**: Azure Container Registry
    - **Azure Subscription: < choose your azure subscription, should be pre-populated from earlier. > 
    - **Azure Container registry**: < your Azure Container service, should be pre-populated from earlier. >
    - **Docker compose Files**: < your docker-compose file in your repo root, should be pre-populated from earlier >
    - **Additional Docker Compose Files**: docker-compose.override.yml (this is the docker compose override file that is in the root of your repo)
    - **Action**: Build service image
    - **Include Latest Tag**: check the box
    
    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline7.png)

9. Configure the **Push services** task using the below settings. If a setting is not mentioned below leave the default settings.

    - **Display name**: Push an image
    - **Container Registry Type**: Azure Container Registry
    - **Azure Subscription**: < default as before >
    - **Azure Container registry**: < default as before >
    - **Docker compose Files**:  < default as before >
    - **Additional Docker Compose Files**: docker-compose.override.yml (as before)
    - **Action**: Push service images
    - **Include Latest Tag**: check the box

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline8.png)

10. Accept the default values for the **Lock services** task and configure the **Copy Files to: $(Build.ArtifactStagingDirectory)** task using the below settings. If a setting is not mentioned below leave the default settings.

    - **Source Folder**: < leave blank to point to the root of the repo >
    - **Contents**:  < ***/docker*.yml >
    - **Target Folder**: $(Build.ArtifactStagingDirectory)

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline9.png)

11. Accept the default values in the **Publish Artifact: docker-compose** task

12. Click on **Triggers** and choose **Enable continuous integration**. This will trigger a CI build when any change in the repo branch occurs.

    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline10.png)

13. To simulate a code check-in, to trigger the continuous integration build, trigger the build by going to your repo and click **Edit** editing the `\src\PartsUnlimitedwebsite\Controllers\HomeControllers.cs` by add a comment to line 11 as below, and clicking **Commit** when finished

    ```powershell
    //CI trigger text
    ```
    
![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline13.png)

    **Note**: You could also just click the **queue** build option, but this method is simulating a CI build based on code check-in.

14. Return to the build pipelines and open the build to view the command line build progress output in the build Console. Time taken to complete can ba approximately 10 minutes for a build to run as it waits to connect and gets queued to access an available build agent.

15. Verify the build runs successfully for both the build an image and push an image tasks.


    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline14.png)
    
    Note: You may receive errors on your first few runs as you iron out configuration issues. This is normal. You should view the build progress as it runs and identify any errors, and iterate your build definition, each time triggering a new build to test your pipeline. You can view each build in the build summary page. It may take several runs to get the build and push working successfully.

16. Go to you **Azure Container registry** and verify the container image is present from the build that was just run. You can click down into the repo and see various image versions present after multiple runs of the build.


    ![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline15.png)

### Task 10: Create a Release Pipeline
Now we will create a release pipeline to deploy our newly application

1. In your Azure DevOps project go to **Pipelines** > **Releases** >  and click on **NewPipeline**

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline1.png)


2. In the **Select a template** pane select **empty job** 

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline2.png)

3. In the **Stage** pane for **Stage name** enter **Smoke Test** and then close the dialogue by clicking the **X** in the top right corner

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline3.png)


4. In the pipeline under **Artifacts** click **Add an Artifact** choose the project and build definition you created earlier, then  for **Source Alias** enter the value **Artifacts**  and click **Add**

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline4.png)

5. Go to **Tasks** >  **Smoke Test** and under **Agent job** > **Agent pool** select **Default**, to indicate that you want to run the commands on the agent you created and used earlier for your build pipeline.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline5.png)

5. On **Agent job** click the **+** sign and in the **Add tasks** > **Build** select **Docker Compose** and click **Add** to add two instances of the task to your pipeline.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline6.png)

6. Still in **Add tasks**  under **Deploy** select **Azure PowerShell** and click **Add** to add the task to your pipeline.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline7.png)

7. Re-order the added tasks in your pipeline so the powershell task is second, between the two docker compose tasks.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline8.png)

8. Configure the **first Docker task** to run the container with the following details, where a field is listed leave the default value.
    
    - **Display name**: Run Services
    - **Container Registry Type: Azure Container Registry
    - **Azure Subscription**: < Your Azure Subscription >
    - **Azure Container Registry**: > the name of your Azure Container Registry >
    - **Docker-compose Files**: < click the ellipsis button at the end of the box and in the artifacts point to labfiles\labs\docker-compose.yml >
    - **Action**: Run service Images
    - Run in background: **Check the checkbox**

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline9.png)

9. Configure the second, or **Azure PowerShell script** task, as per the below, again where a field is listed leave the default value.

    - **Display name**: Azure PowerShell script: FilePath
    - **Azure Connection Type**: Azure Resource Manager
    - **Azure Subscription**: < Your Azure Subscription >
    - **Script Type**: script file path
    - **Script Path**: < click the ellipsis button at the end of the box and in the artifacts point to labfiles\labs\docker-compose.yml >
    - **Azure Powershell Version**: Latest installed version
 
    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline10.png)

10. Configure the third, the **last Docker task** as per the below, again where a field is listed leave the default value.

    - **Display name**: Run a Docker Compose command
    - **Container Registry Type**: Azure Container Registry
    - **Azure Subscription**: < Your Azure Subscription >
    - **Azure Container Registry**: > the name of your Azure Container Registry >
    - **Docker-compose Files**: < click the ellipsis button at the end of the box and in the artifacts point to labfiles\labs\docker-compose.yml >
    - **Action**: Run a docker compose command
    - **Command**: down

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline11.png)

11. Go to the **Pipeline** and within **Artifacts**, click on the **continuous deployment trigger** icon Triggers tab and enable Continuous Deployment.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline12.png)



13. Save the Release pipeline, by clicking **Save**

14. Click on **+ Release** > **+ Create a Release** and in the create new release dialogue  select the latst artifact version and then click **Create**. This will run just the release pipeline, and not the previously defined build definition, to verify your configuration

   ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline13.png)

15. If it completes successfully, It should deploy the partsunlimitedwebsite container image to the build agent, the azure virtual machine you deployed earlier. You can verify that by viewing the **docker ps -a** command output on the build agent, and verifying the container was up and running. You can also get the IP address using Docker Inspect < container ID > and opening a browser, to verify the page displays successfully.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline14.png)

    You can also view the Logs tab content in the VSTS release pipeline, it will contain all the command line output and details from the deployment. The output of the Powershell task in the logs should also contain **Statuscode: 200** and **status description: OK** and some html and other details which the script has taken from the running website to verify it has deployed successfully. If the website in the container was not running successfully, it would not return this data.

    ![](../assets\cdwithcontainersandazdevops-jan2018/releasepipeline15.png)

    Another option to verify the deoloyment is to disable the last docker task and run a new release, then obtaining the public IP address of you build agent virtual machine, and going to that ip address and port 8080, i.e. http://<ipublicipaddress>:8080, as the host port on the agent of 8080,. is mapped to the container port 80. The Partsunlimited web site should display successfully in a browser.

    Also, when editing the release pipeline, be sure you are editing the actual release pipeline and not a past pipeline that has already been run, i.e. which have the default label of Release-1, -2, -3, 4 etc. If you edit these releases, and save the changes, that will not affect the general definition. Right click on the release pipelines as defined under Release pipelines pane, and choose edit, then Save your changes here. Otherwise, you may think you are editing the release definition but are actually editing a previous run of the definition.

16. You should run the release a couple of times and verify it runs successfully, each time checking the Logs, and various configuration options.


### Task 10: Run the full Continuous Integration and Continuous Deployment pipeline

We will now run the build and release definitions.

1. To simulate a code check-in, to trigger the continuous integration build, trigger the build by going to your repo and click **Edit** editing the `\src\PartsUnlimitedwebsite\Controllers\HomeControllers.cs` by add a comment to line 11 as below, and clicking **Commit** when finished

    ```powershell
    //CI trigger text
    ```
    
![](../assets\cdwithcontainersandazdevops-jan2018/buildpipeline13.png)



2. Return to the build pipelines and open the build, to view the command line build progress output in the build Console.

3. Once the build is complete, the release should start automatically.

4. View the release progress by viewing the Logs tab there to verify successfully deployment.

5. Verify the container has been deployed successfully to your build agent and open the IPAddress in a web browser is now visible on the web page.

    **Note**: As stated earlier, you may receive errors on your first few runs as you iron out configuration issues. This is normal. You should view the build progress as it runs and identify any errors, and iterate your build definition, each time modifying your Azure DevOps repository file to trigger a new build. You can view each build in the build summary page. It may take several runs to get the build and push working successfully.


### Task 11: Optional additional configuration on release pipeline

When deploying to a test environment, which we are simulating here, you would typically deploy the application, then perform some tests, built into your release definition, then perform some clean up tasks, to leave a clean deployment environment for the next deployment. We will not include tests in this release definition, as it would add to complexity and time requirement and is a whole topic on its own, we could also add additional release tasks

- We could add a task here to Remove an Image, and enable the task by checking the Enabled checkbox.
- Add some tasks performing some other tests on the deployed container and image
- You could also add additional release environments for Staging, Production etc, each time adding additional tasks required for that stage, such as unit tests, verification tests etc.
- You can also build in additional configuration options around approvals before deploying to production as well as many other options. You should click around and modify your settings to try different scenarios and configuration options as you have time.


<h3><span style="color: #0000CD;"> Summary</span></h3>

In this lab you completed the following tasks:
- Created a new Azure DevOps Project
- Created Git repo and Import PartsUnlimited git repo
- Created a Personal Access Token (PAT)
- Created a Service Connection in Azure DevOps
- Added Docker support to the application using Visual Studio 2017
- Created Azure Container Registry
- Deployed a virtual machine to Azure to use as an Azure DevOps build agent
- Installed and configure the build agent
- Created a Build Pipeline
- Created a Release Pipeline
- Ran the full Continuous Integration and Continuous Deployment pipeline
- Performed some optional additional configuration on release pipeline